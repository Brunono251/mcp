#!/bin/bash

set -euo pipefail

# Colors for output (only when stdout is a terminal)
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m' # No Color
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

# Script configuration
GOLANGCI_LINT_VERSION="v1.61.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
GOLANGCI_CONFIG="$PROJECT_ROOT/.golangci.yml"

# Output file for JSON results
JSON_OUTPUT_FILE="${PROJECT_ROOT}/lint-results.json"

show_usage() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS]

Run comprehensive linting checks on the Go codebase.

This script performs the following checks:
  1. go mod verify - Verify module dependencies
  2. go mod tidy - Check if go.mod and go.sum are tidy
  3. gofmt - Check Go code formatting
  4. go vet - Run Go's built-in static analysis
  5. golangci-lint - Run comprehensive linting with custom config

OPTIONS:
  -h, --help    Show this help message and exit
  -v, --version Show golangci-lint version and exit

OUTPUT:
  Results are displayed in the terminal with colored output.
  If issues are found, detailed results are saved to lint-results.json
  in JSON format for integration with other tools.

EXIT CODES:
  0  All checks passed
  1  One or more checks failed

EXAMPLES:
  $(basename "$0")           # Run all lint checks
  $(basename "$0") --help    # Show this help
  $(basename "$0") --version # Show golangci-lint version

EOF
}

show_version() {
    echo "golangci-lint lint script"
    echo "Target golangci-lint version: $GOLANGCI_LINT_VERSION"
    if command -v golangci-lint >/dev/null 2>&1; then
        echo "Installed golangci-lint version: $(golangci-lint version --format short 2>/dev/null || echo "unknown")"
    else
        echo "golangci-lint: not installed"
    fi
}

echo_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

echo_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

echo_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

echo_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if golangci-lint is installed and install if needed
install_golangci_lint() {
    local current_version
    
    if command -v golangci-lint >/dev/null 2>&1; then
        current_version=$(golangci-lint version --format short 2>/dev/null || echo "unknown")
        if [[ "$current_version" == *"$GOLANGCI_LINT_VERSION"* ]]; then
            echo_info "golangci-lint $GOLANGCI_LINT_VERSION is already installed"
            return 0
        else
            echo_warning "golangci-lint version mismatch. Current: $current_version, Required: $GOLANGCI_LINT_VERSION"
        fi
    fi
    
    echo_info "Installing golangci-lint $GOLANGCI_LINT_VERSION..."
    
    # Install using the official installation script
    curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b "$(go env GOPATH)/bin" "$GOLANGCI_LINT_VERSION"
    
    # Verify installation
    if ! command -v golangci-lint >/dev/null 2>&1; then
        echo_error "Failed to install golangci-lint"
        exit 1
    fi
    
    echo_success "golangci-lint installed successfully"
}

# Run go mod tidy and check for changes
check_go_mod_tidy() {
    echo_info "Checking go mod tidy..."
    
    # Create a temporary directory for comparison
    local temp_dir
    temp_dir=$(mktemp -d)
    
    # Copy current go.mod and go.sum
    cp "$PROJECT_ROOT/go.mod" "$temp_dir/go.mod.orig" 2>/dev/null || true
    cp "$PROJECT_ROOT/go.sum" "$temp_dir/go.sum.orig" 2>/dev/null || true
    
    # Run go mod tidy
    cd "$PROJECT_ROOT"
    if ! go mod tidy; then
        echo_error "go mod tidy failed"
        rm -rf "$temp_dir"
        exit 1
    fi
    
    # Check for changes
    local mod_changed=false
    local sum_changed=false
    
    if ! diff -q "$PROJECT_ROOT/go.mod" "$temp_dir/go.mod.orig" >/dev/null 2>&1; then
        mod_changed=true
    fi
    
    if ! diff -q "$PROJECT_ROOT/go.sum" "$temp_dir/go.sum.orig" >/dev/null 2>&1; then
        sum_changed=true
    fi
    
    rm -rf "$temp_dir"
    
    if [[ "$mod_changed" == true ]] || [[ "$sum_changed" == true ]]; then
        echo_error "go mod tidy resulted in changes. Please run 'go mod tidy' and commit the changes."
        echo_error "Changed files:"
        [[ "$mod_changed" == true ]] && echo_error "  - go.mod"
        [[ "$sum_changed" == true ]] && echo_error "  - go.sum"
        exit 1
    fi
    
    echo_success "go mod tidy check passed"
}

# Run go mod verify
check_go_mod_verify() {
    echo_info "Verifying go modules..."
    
    cd "$PROJECT_ROOT"
    if ! go mod verify; then
        echo_error "go mod verify failed"
        exit 1
    fi
    
    echo_success "go mod verify passed"
}

# Run go vet
check_go_vet() {
    echo_info "Running go vet..."
    
    cd "$PROJECT_ROOT"
    if ! go vet ./...; then
        echo_error "go vet found issues"
        exit 1
    fi
    
    echo_success "go vet passed"
}

# Run gofmt and check for changes
check_go_fmt() {
    echo_info "Checking go formatting..."
    
    cd "$PROJECT_ROOT"
    local unformatted_files
    unformatted_files=$(gofmt -l . | grep -v vendor/ | grep -v third-party/ || true)
    
    if [[ -n "$unformatted_files" ]]; then
        echo_error "The following files are not properly formatted:"
        echo "$unformatted_files"
        echo_error "Please run 'gofmt -w .' or 'go fmt ./...' to fix formatting"
        exit 1
    fi
    
    echo_success "go formatting check passed"
}

# Run golangci-lint
run_golangci_lint() {
    echo_info "Running golangci-lint..."
    
    cd "$PROJECT_ROOT"
    
    # Verify config file exists
    if [[ ! -f "$GOLANGCI_CONFIG" ]]; then
        echo_error "golangci-lint config file not found: $GOLANGCI_CONFIG"
        exit 1
    fi
    
    # Run golangci-lint with JSON output
    local exit_code=0
    golangci-lint run --config="$GOLANGCI_CONFIG" --out-format=json --print-issued-lines=false --print-linter-name=false > "$JSON_OUTPUT_FILE" || exit_code=$?
    
    # Filter out Go toolchain false positives if jq is available
    if command -v jq >/dev/null 2>&1 && [[ -f "$JSON_OUTPUT_FILE" ]]; then
        local filtered_output="${JSON_OUTPUT_FILE}.filtered"
        jq --arg project_root "$PROJECT_ROOT" '
            {
                Issues: [
                    .Issues[] | select(
                        (.Pos.Filename | startswith($project_root)) and
                        (.Pos.Filename | contains("/go/pkg/mod/") | not) and
                        (.Pos.Filename | contains("/third-party/") | not)
                    )
                ],
                Report: .Report
            }
        ' "$JSON_OUTPUT_FILE" > "$filtered_output" && mv "$filtered_output" "$JSON_OUTPUT_FILE"
    fi
    
    # Check if there were any issues
    local issue_count
    issue_count=$(jq '.Issues | length' "$JSON_OUTPUT_FILE" 2>/dev/null || echo "0")
    
    if [[ "$exit_code" -ne 0 ]] && [[ "$issue_count" -gt 0 ]]; then
        echo_error "golangci-lint found $issue_count issue(s) in project code"
        echo_error "Detailed results saved to: $JSON_OUTPUT_FILE"
        
        # Also show a summary to stdout for immediate feedback
        if command -v jq >/dev/null 2>&1 && [[ -f "$JSON_OUTPUT_FILE" ]]; then
            echo_error "Summary of issues:"
            jq -r '.Issues[] | "  \(.Pos.Filename):\(.Pos.Line):\(.Pos.Column): \(.Text) (\(.FromLinter))"' "$JSON_OUTPUT_FILE" 2>/dev/null || true
        fi
        
        exit 1
    fi
    
    echo_success "golangci-lint passed (checked $issue_count issues)"
    # Clean up empty results file
    if [[ "$issue_count" -eq 0 ]]; then
        rm -f "$JSON_OUTPUT_FILE"
    fi
}

# Main execution
main() {
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_usage
                exit 0
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            *)
                echo_error "Unknown option: $1"
                echo_error "Use --help for usage information"
                exit 1
                ;;
        esac
    done
    
    echo_info "Starting lint checks for $(basename "$PROJECT_ROOT")..."
    echo_info "Project root: $PROJECT_ROOT"
    
    # Ensure we're in a Go project
    if [[ ! -f "$PROJECT_ROOT/go.mod" ]]; then
        echo_error "Not a Go module (go.mod not found in $PROJECT_ROOT)"
        exit 1
    fi
    
    # Install golangci-lint if needed
    install_golangci_lint
    
    # Run all checks (fail fast)
    check_go_mod_verify
    check_go_mod_tidy
    check_go_fmt
    check_go_vet
    run_golangci_lint
    
    echo_success "All lint checks passed! âœ¨"
}

# Handle cleanup on script exit
cleanup() {
    local exit_code=$?
    if [[ $exit_code -ne 0 ]] && [[ -f "$JSON_OUTPUT_FILE" ]]; then
        echo_info "Lint results available in: $JSON_OUTPUT_FILE"
    fi
}

trap cleanup EXIT

# Check for required tools
if ! command -v curl >/dev/null 2>&1; then
    echo_error "curl is required but not installed"
    exit 1
fi

if ! command -v jq >/dev/null 2>&1; then
    echo_warning "jq is not installed. JSON output parsing will be limited."
fi

# Run main function
main "$@"
